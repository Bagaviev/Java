Hashcode equals contract

Если equals ==, hashcode обязательно ==
Если hashcode ==, equals могут быть !=. Случай коллизии
Если equals != hash code !=


HTTP запросы

Есть методы (GET, POST, etc)
Есть строка запроса - сам урл
Есть тело запроса (HTML, json)
Есть заголовки (параметры): Keep-Alive, Cookie, Accept, etc
Для get параметры передаются в строке запросу в открытом виде, в post в теле. Поэтому для https протокола данные будут скрыты только для POST
====
HTTP ответы тоже самое только со статусом ответа 200, 404, etc


Active directory

То как в МТС было
Имя рабочей группы: company.domain.com
Механизм авторизации в винде и соотв разграничения политик, групп, учеток


Docker

Создаём dockerfile (базовый образ, что делаем и тд)
Собираем build контейнер
На выходе будет наш образ
Dockerfile > image (build) > container (run)
Типа лёгкая виртуализация (Linux образ на linux os запустить ок, ядро будет хостовой ос использоваться. Однако на винде не заработает)


Extract method AS

Ctrl alt M


Git merge conflicts

Когда в удаленной репе изменения, и в той же строке мы своё делаем
Потом пытаемся push сделать, он падает, затем pull и происходит конфликт
Решается ручным редактом файла проблемного, либо командой git checkout --ours filename.txt
Повторный pull, затем push
2 способа очистить историю комиттов есть


Esni Dns

Технология сокрытия dns имени хоста для провайдера и третьих лиц. Более слабый аналог vpn
Firefox только поддержку имеет. Duckduckgo нет
Только https + сайты которые поддерживают эту технологию
Потом переедет ech
To do// зачекать VPN трафик
В итоге настроил, но переходить на другой браузер не охота, и непонятно заработало или нет


Map sort by value

Надо городить stream с comparingByValue()


Map last element

Надо скастить в LinkedHashMap()
Потом у него entrySet() взять
После уже у последнего .get(size()-1)) сделать, и потом уже у посл entry взять getValue()


Ahk scripting

Прикольно скриптинг команд на windows


Git merge conflicts

Когда в удаленной репе изменения, и в той же строке мы своё делаем
Потом пытаемся push сделать, он падает, затем pull и происходит конфликт
Решается ручным редактом файла проблемного, либо командой git checkout --ours filename.txt
Повторный pull, затем push
2 способа очистить историю комиттов есть


Mutators

== setters


Another strings moment

String str = "et"
True: str == "et"
kek = str
True: str == kek
Но для new String() false


В switch

Только подавать final static string, не final не подойдут


Java constructors

Сами вставляются даже если не указывать в дочернем обьекте. И вызываются родительские


Системные параметры

Runtime.getRuntime().getCores()
.maxMemory() объем jvm heap покажет (350мб на моём)


Сортировки:

Bubble (пузырек) два соседних элемента попарно сравниваются, с каждым проходом меньший всплывает влево как говно, и след итерация на элемент меньше смотрит
Шейкерная мин макс элементы в один проход всплывают на разных концах
Расческа (comb) модификация с уменьшающейся шириной прохода
Selection (выбором) находится минимум в проходе и обменивается местом с первым элементом, и тд
Insertion (вставками) элементы сдвигаются вправо пока меньше первого изначального, потом изнач вставляется влево
Shell (Шелла) это расческа для вставок
Quick (быстрая) рекурсивная самая дроченая пока что, разбиение посередине, проход двумя маркерами с обоих концов, и рекурсия 2 подсписков, где слева элты меньше опорного, справа больше


Куча

Отдельная структура данных (еще есть способ организации памяти такой, это другое), типа дерева, где максимум в корне, и она позволяет быстро доставать элемент с макс приоритетом
Делается на priorityQueue


Репы

Сейчас 2 репы:
Java где проектики и JR
И android projects
Остальное не поддерживаю (универские + со старой работы)
Будет новая работа будет ещё один репо


Bat-ник git

Удобно, файл кинул в системе, потом кликнул по скрипту, он отработал и залил все куда нужно
Главное, только чтобы это запускалось из той директории, что в таргет репе


Git repo

Всегда содержит скрытую папку .git
Значит директория под vcs


Nested git repos
Осторожнее, надо . git убирать внутри основного репо, у вложенных репо


Merge conflicts

Если ошибка при pull с сервака, то надо параметр --allow-unrelated-histories делать
Если потом конфликт, то руками исправлять через git mergetool (ебаный свет какая параша). Выйти из этой бабуйни q
Потом git checkout --ours filename, потом add, commit
Возникает, когда файл на серве обновился, а мы пушим туда наш outdated file. Тогда надо выбрать какую версию толкнуть, либо руками править строки.
Для этого все работают в отдельных ветках, а потом merge в мастер происходит


Git

Сделал папку версионированную с исключением .gitignore другого репо в ней (менеджится через ide)
Win search

Win + s


Win проводник

Long press Alt, хоткей к меню


This()

Вызывает текущий конструктор


Xml

Если в тегах есть вложенные теги другие, то первый должен быть парным <...> абс </...>
Если нет, то может быть непарным < ... />


Javы на ноуте

Отдельная jre для запуска jar разных легаси
Jdk 15 для idea
Bundled Android Studio jre, но юзаю 15 как в idea


LRU кэш

Типа структура где в начале стека типа горячие значения, ниже холодные. Делается на LinkedHashMap()


HashMap

Nullable key OK
TreeMap not nullable key!


Skiplist

Жеская вероятностная структура данных. Несколько связных списков где пропускается части значений по ссылкам
 + ConcurrentHashMap классно работает - позволяет дописываит в уже читающуюся коллекцию, и блокирует тока бакеты, а не весь мап


None blocking concur

Неблокирующий параллелизм, основанный на итераторах и состояниях.
Позволяют более эффективно по времени работать с одновр чтением/записью в коллекцию, без concurrentModificationException()


Bidimap

Получение ключа в обычной мапе дольше происходит, чем значения по ключу. Для решения придуман bidimap


HashMap inside

Состоит из бакетов где каждый это связный список ключей, значений, хеша. Этот бакет Node<>
Array of linkedlists


Поиск ключа/знач

Знач просто get()
Ключ в цикле перебор keySet()


Генерация ранд строки

BigInteger(130, new SecureRandom()).toString(36)


Свой мультимап

Пилил в одной задаче, удобная тема. Мапа ключей - списков значений.


No default constr:

Происходит когда нет пустого констр в род классе. Лечится созданием его в род или в детях другого, с вызовом super()


Табы или пробелы:

Табы вроде


HashSet/Map nuance:

Если изменить данные объекта, его хеш поменяется, есть вероятность с коллекции не найти этот объект
Гарантировано только с immutable объектами работает
Лечится удалением/добавлением элемента


Concurrent Collections

Нужны для потокобезопасной работы без явной syncronization()
CopyOnWriteArrayList


Array list init

List<String> pl = new ArrayList<String>(Arrays.asList("shsh", "she", "siw"));


Сравнить 2 кода IDEA

Copy первый кода
Открыть второй
Пкм Compare with clipboard


Bean

Объект для хранения данных, entity
Dto для транспортировки
Dao для работы с бд, сохранением и тд


Chrome инс разраб:

Ctrl shift I > network
Смотрим jsники и запрос/ ответ


Java EE

Типа аналог Spring
Куча либ для создания веба


Factory method vs Abstract fabric

Первый - метод, работает с одним семейством объектов
Второй улучшение первого, - объект, который управляет созданием семейств других объектов


Classloader:

3 штуки есть
Каждый класс знает кто его загрузил - Cat.class.getClassLoader()
Cat.class == cat.getClass() тупа имя класса полное
forName для загрузки класса


Pecs

Producer extends consumer super
Типа list<? extends Animal> можно вытащить элемент, но нельзя вставить
Наоборот при list<? super Cat> вытащить не получится, но засунуть туда можно
Extends не включительно
Super включительно
Конварианьность \ контрвариантость


ArrayList raw use

Можно кароче разные типы напихать в list без <>
И вывести в консоль. Но при более сложных конвертациях все наебнется. Поэтому делают generic collection


Generics

Тип класса T, элемент списка Е, мапа - K, V
Type parameter <T>
Static <T> T method(T arg)
Class<T> {}
Class<T extends ClassB> - можем у t вызывать методы В
List<? extends Object>
Нужны чтобы ограничить или позволить юзать классы/методы с различными типами. Чтобы не в рантайме обсиралось, а на этапе компила
List<? super MyClass> значит предки этого класса
Wildcards - extends upper, super lower bound
Стирание типов - чтобы инстанс типизированного объекта создать, нужно ссылку в классе сохранять, и передавать в констр


Git undo

Git reflog (или log) - логи действий гита
Git reset --hard commit_hash - локальные файлы поменялись на состояние из коммита
Git revert hash - новый коммит с обратными изменениями, потом push надо сделать
Git pull origin master - изменили локальную копию свежой инфой с репы
Git show hash че изменилось
Gitk GUI
Head - указатель на выбранный коммит


Linked structure lookup:

While (голова не нулл)
Если голова равна ключу, отдаем, иначе голова равно след.голова
Возвр нулл если не нашли
Также в for(Entry entry = table[index]; entry != null; entry=entry.next)


Хэш таблицы

Типа мапа, массив списков
Где индекс генерится на основе ключа хеш функцией. Поэтому о(n)
(!) Положение элемента в таблице зависит от его значения
Борьба с коллизией
Separate chaining
Open addressing


Графы

Задаются матрицей смежности (инцидентности)
Списками смежности. Массив где каж элемент список


Алгоритм Дейстры

Кратчайшие пути в графе. Кажется логичным и несложным

Git
Также делается пулл реквест в браузере после пуша
Pull request - запрос на принятие изменений
Чтобы подсвечивал правильный маркер нужно в jr папке удалять .1 файл лога, а в своей jaava убирать html (сделано)


Logging

Embed: Java until logger (system.err)
Log4j / Slf4j
Кароче юзал связку последних двух. Там файл конфига приписывается как логировать. И в коде приписывается к нему путь и регистрируется. Ну и что логить тоже в коде функциями logger.debug("text") прописывается


Runtime type vs. Static type

A.getClass() A.class
Юзается для рефлексии


Jvm heap size:

Ограничение
VM params: -Xms256m -Xmx512m


Weak/Soft reference

Если софт, то при нехватки памяти объект будет удален, при отсутствии strong ссылок
Если weak, то при первом gc будет удален


Java JDBC

В итоге сделал пример CRUD методами работающие с MySQL с properties параметрами вынесенными, с импортом через мавен (проект мавен, но сборка обычная, только зависимости). С preparedStatements


Prepared statement

Чтобы SQL не за инжектили


DB connector IDe integration to MySQL

Топ тема, правда ебка с таймзоной, но не суть. Запускаем сервис сервера бд, потом можем коннектиться клиентом
После уже из intellij видим бд и прочие штуки
Чтобы просто селектить из бд этого достаточно, но чтобы из кода вызывать БД, надо уже методы юзать и jdbc driver импортнуть и в коде подсосать.
С таймзоной надо в коннекте прописать, и мб если не поможет ещё и в консоли бд (можно из идее)


MySQL Workbench

Bug! Неправильно работал, с ошибкой. В логах пайтон уникоде еррор и решение в блоге оф сайта mysql - юзать административный язык раскладки приложений по умолчанию english US, если utf-8 не доступен. С этим осторожно - Идея сломалась, пришлось вернуть как было
Работает из консоли mysql -u admin - p, затем ввод пароля


Бин поиск

Половины массивов отбрасываем и рассм большую, если искомое число больше середины массива
Может быть интерактивным или рекурсивным


Xml

Чтобы конвертнуть объект в этот формат нужно юзать JXAB (как jackson)


Dependencies

Это либо в мавене
И паттерн d injection, где мы не руками создаёт объект другого класса в текущем, а принимаем его в конструкторе или сеттером
Ещё может быть более сложно сделано все через сторонний объект, который собирает это (service locator).


JRE/JDK

Когда нужно открыть exe из jar какойто легаси, то в системных переменных среды там выше делаем jre 8. В остальных случаях jdk 15


Jackson

Либа для работы с JSON
Объект в json строку, в файл. ObjectMapper
Если чето там не получается сериализовать, то аннотации надо полиморфные делать


Типизация

Статическая - Java [компилируемый]
Типы до компиляции. Ошибки до компиляции
Динамическая - Python [интерпретируемый]
Типы во вр компиляции. Ошибки в runtime
Сильная (строгая)
Python 1 + "2" err. Без скрытых преобразований.
Слабая (нестрогая)
Java 1 + "2" = 21 преобразования скрытые происходят


Uml idea

В бесплатной версии крайне сложно сделать бесплатно чтобы генерилось диагр классов
В платка есть вроде поддержка


Service locator

Как di примерно работает, для разделения потребителей сервиса и конкретных классов. Без new obj(), а через фабричный обьект
Baeldung


Std.err

Как std.out только подсвечивается подругому. Ну и обрабатываться может по другому


Random access/rmi

Есть такие темы когда в файл надо писать в середину, а не последовательно.
И вызывать методы/поля объекта удаленного на другой jvm


Тип переменной

var.class или var.getClass().toString()
Похоже как инстанс оф


Dynamic proxy

Подмена объекта копией с доп функционалом
Как подмена printStream типа такого же


Map inside map

Map<Integer, Map<Character, Integer>> такую штуку делал, забористо но работает
Md5 digest() делали


Hashmap init

Сразу значения после new Hashmap<>() {{ put (1,1) ...}}


Import static

Для красоты использования сторонних методов


Mockito

Либа для подстановки реальных данных тестовыми, подмена поведения (отвязки от соед бд и эмуляция этого)


Assert

Выражение для проверки данных, типа if условия
Нужно включить в идее, параметром -ea


Тесты

Юнит (модульное)
Функциональное (gui)
Интеграционные
Приемочные
Ручные
Нагрузочное
Модульные > сервисные > интеграционные
Регресс теста - при добавлении нового кода перестает работать то, что уже работало
Автотесты после изменений сами запускаются после компиляции


JUnit

Добавляем либу через project structure - libraries
Или просто через alt ins по имени класса в коде и test, потом предложит подцепить либу изи уже подцепленную заюзать
Появляется класс TargetclassTest, с аннотациями @test
Код в мейне сравниваем по одному методу с тестом, на похожесть данных методом Assert.equals(exp, act)


Обход дерева:

Может быть в глубину (итерационный, рекурсивный, через стек)
Может быть в ширину (очередь)


Binary tree:

Один корень - 2 потомка. Слева меньший, справа больший
Обход рекурсивный либо через Stack (LinkedList)
Log(n) глубина, типо оптимальный.
Используется в реализациях TreeMap/TreeSet (сам сортирует по ключу)


Context menu Windows:

Shift + f10 (in explorer)


HashTable vs. HashMap

Одна история про key value
Но таблица потокобезопасная, мапа - нет
Бакеты в хештабл - ключ на вход хеш функции. Далее по входным параметрам, легко расхешируем где же лежит искомое value


Взять все элты кроме 1:

ArrayList.subList(1)


Загрузчик файлов из инета

Делается через класс URI
Также сделать директории и прочее через Files.
Засплитить путь и взять только имя файла - через сплит(/) [ сплит().длина - 1]
Если условий проверок много, то нужео делать начальные данные подходящие всем ("") etc, а потом через И общее условие бахать. Либо последовательно if не, не связанные


Обход дерева файлов:

File + рекурсия
File + queue
Files + walkFileTree()
Directory Stream


Reformat code (!)

Удаляет комменты нахер
Optimize imports прячет


Компактный компаратор:

Так можно еще упростить сортировку обьектов. Сначала класс отдельный наследующий компарабле, потом анонимный класс, потом лямбда, потом вот такая конструкция.
Comparator.comparing(File::getName())


Рекурсия своя:

Работает поиск файлов в поддиректориях


Битовые маски:

В одной int перемен (10) можно хранить 32 логических других переменных
Сумма чисел даст общее закодированное значение.
Получить & 01000
Установить |= 10111
Сбросить &= 01000
Можно сдвигами делать
В 1 бит 6 result |= (1 << 6)


Observer:

Один код наблюдатель другой наблюдаемый
Метод update() что отработает при вызове setTriggered в наблюдаемом


Троичная система

Есть симметричная -1 1 0
Там задача с грузами, двойки представляются старшей степень 3 и текущей отрицательной


Унарные бинарные операторы:

&& - проверка lazy
& - full


Быстро разбить на 2 окна:

Win + up/down...


Palindrom

Str reverse = str original


Переводы систем исчисления:

Класс BigInteger
String


Breakpoint

Ctrl + f8
F7 jump next line
Ctrl + f9 debug


Producer/Consumer:

В задаче ресторан
Типа паттерн - общая конкаррент очередь


Задать рандом диапазон

Math.random() * list.size()
0..1 * 10 даст номер из списка


Xor in Boolean expr:

!isActiveParam ^ var.isActive()
Выбор тру или фалсе значений из списка в одной функции


Алгоритмы:

Есть жадные - типа сортировка по удельной стоимости
Есть динамические (они лучше, но сложнее)
Есть Армстронга
Укладка рюкзака
Ханойские башни


Рекурсия:

Условие выхода из нее
Условие продолжения - вызов самой себя с параметрами прошл шага
Сначала погружаемся в стек вызовов, потом раскручиваемся из него обратно


Scroll условие shortcut:

Alt f2 custom context menu command, on selected условие panel даст возможность скроллить, без клика мышкой


Context menu win

All programms - shift + f10, but intellij that run command


Magic:

"str".sout + tab обернет все в system.out.printLn


Подсветить переменную

Без даблклика - ctrl shift f7


Быстрый replace

Ctrl shift r, такое странно работает


Сообщение ошибки:

Ctrl + f1
Alt + enter лампочки


Параметры метода:

Чтобы не открывать, ctrl + p


Debug

Shift + f9
Бреакпоинт > evaluate expr alt + f8


Кэширование чисел до 127

New Integer == другому числу вернет true


Ctlrl + q

Дает открыть доки на методе


Refactor IDE

Rename var/method shift + f6
HasMethod() для boolean


Ахуеть intellij:

Такая умна подсказывает методы в зависимости от контекста, угадывая мои желания


Mvc moments:

View сама себя не обновит, делается отдельный метод и вызывается в controller
Контроллер должен быть тонким


Передача boolean метода как параметр в set метод
Разделение listener'ов позволяет разным компонентам реагировать по разному на курсор/ввод


Упрощение ifов

var.setMethod(ch.isTrue())
var2.setMethod(ch.isTrue())
Вместо сложной логики проверки условий


Конструкторная ебка:

Если требует его наличие без параметров, а в коде вызывается с параметрами, то делается без параметров, вызывается super(null)


#Jsoup

Либа для разбора html
И парсинга данных с сайтов


Maven moments:

Нужен для авто подгрузки либ к проекту, без cp ебки
Как pypl суть та же (загрузка модулей из репы удаленной) pip
Bundled maven with intellij, руками ставить не пришлось. Можно проект так передать через импорт, все либы сами подсосутся.
Pom.xml это по сути список либ проекта.
При создании проекта задаем ни java а maven тип. Далее можем настроить адрес репы откуда качать либы.
Потом добавляем dependencies теги, а в них dependency код с сайта репы
Еше можно кликать add library через ide
Все потом обновл кнопку и либа подсасывается сама и появл слева. Потом просто импорт и юзаем.
Была ошибка при сборке - дичь типа version error. Решилось settings build version target 10
Еще можно собирать проект по мавеновски:
Потребовалось плагины какието вкорячивать в xml
И мавен конфигурацию делать, где параметры магические прописывать. После этого вывод был ок при сборке.


Object pool:

Паттерн для уменьш кол-ва создаваемый обьектов дорогостоящих


Phaser

Позволяет создать этапы для сопоставления потоков барьеру и после опр этапа пробросить через барьер
ariveAndAwaitAdvance() ожидать
arriveAndDeregister() заверешние фаз


Thread managers

ThreadPoolExecutor() сам мэнэджит потоки - при работе с потокобезопасной очередью
Отличается от ExecutorService Executors. Просто много тасков на малом колве нитей. Нужно когда вычисления легче, чем сам код поднятия потоков.


Static/non block

Нужен для экономии места при создании объекта и не допускания разноса вызова общей функции по конструкторам


Random in Threads

Надо юзать специальный рандом, чтобы результат в неск потоках был неконкурентным


ForkJoinPool

Типа executorService более легковесный и эффективный чем обычные нити, типа меньше простаивают
Нужны когда рекурсивную задачу распараллелить
Нити не простаивают, а крадут задачи у более загруженных тредов
Делается методом invoke


Atomic

Повнимательнее с положением getAndIncremet(), результат разнится, надо статик делать и в конструкторах вызывать. А в sout только параметр толкать


Resolve path

Для склейки относ пути и абс
Обратно - relativize: вычленение относ пути касательно абс
Еще normalize для избавл от . . (Могут возникн при relativize)
NIO - files/paths


Wildcards:

Подстановочный знак -Вот такая дрисня <?> в дженериках. Означает что любой тип можно будет использовать в методе/классе и он будет задан на лету


File класс

Для работы с директориями/обработкой файлов (и содержимого, nio)
Устаревшая темая вместо нее Paths, Files
Files: Readalllines(), readallbytes()
ZipOutputStream


Notify() / wait()

Внимательнее смотреть на каких мониторах их запускать, в тех же синх блоках


Вложенный sync блок:

Значит из 1 потока блокируется 2 объекта (надо порядок уст руками, иначе дедлок будет)
Sync
Sync


Concurrency синхронизаторы:

Нужны когда логика потоков усложняется - один ждет другого, проверяет состояние и тд
Semaphore/cyclicBarrier/countDownLatch/FutureTask
ThreadLocal - типо локальной переменной одной, но с каждым значением в своем потоке (как кэш без volatile)


Execute vs submit

ThreadService
Лучше юзать execute, он не скрывает исключения


Deadlocks

Бывают:
Порядка синхронизации
Между разными объектами классов
Ресурсные (~1)
Борьба:
Установка порядка sync объектов по id или hash, и руками логику. Типа если обоим надо - берет старший.
Открытые вызовы
Доп монитор
Проверка перед захватом (try lock)
Lock interubtible
Диагностика:
Thread dump (Jps + jstack + номер pid + kill -3 (опц)) лок
IDE: analyze: thread dump (туда копируем лог и он отрисосывает красивее в идее)
Еще есть всякие jconsole gui для просмотра (builtin jdk tools)
логирование


Сторонние либы в IDE

1) Мавен артифакт
2) Делается это во вкладке project > modules .По идее само должно подключаться после загрузки sdk fx и его указания пути. Работает!
На примере JavaFX, спец проект с параметром требует либо jdk с javafx либо либо передать в cp.
Потом индексируется и подсасывается можно в трее меню слева увидеть пункт external libraries
3) Можно изнутри IDE достать либу (не через мавен артифакт, и не руками файлы либы положить и подкл, а кликами только)


Заюзать стороннюю либу Java

1) Копирнуть код
2) Импортнуть из мавена, файлов руками и подключить в проект
Сделать подкласс наследующий от либы и родительского класса
Создать обьект класса либы
Использовать обертку

===================INFO====================
workbench была бага - пофиксил кодировки там, теперь работает (чек коммент на стековерфлоу) - ОСТОРОЖНО ! перестала работать Идея после этого, вернул назад
Запуск сам при старте винды + ворбенч все отображает.
Надо делать кастомный коннект для DB Navigator - дроч с таймзонами jdbc:mysql://localhost:3306/mysql?serverTimezone=UTC&useSSL=false
	можно делать команду в mysql shell но это тупо, лучше в настройках Идеи один раз прописать.
	вообще SET GLOBAL time_zone = '+3:00'; помогло делал и там и там (в идее и в консоли бд)
===================START===================
Server:
	Служба MySQL80 в WIN+R > services.msc > run manual (для сервака)
	Все службы: sc queryex type=service state=all | find /i "SERVICE_NAME:"
	Состояние одной конкретной: sc query myService
	Или net start MySQL57 / net stop MySQL57
Client:
	Просмотр с сосноли: mysql -u admin -p   > enter pwd > OK  (делать в папке sqlserver/bin)
	Ну либо отдельным приложением CLI
	Инфа о сервере: mysql > status
	Ну а дальше как обычно: USE DB, Show smth...
	show processlist


Структура ide

Пример проект GUI
1 пакет, n mainoв запускаемых


Swing in IDE

Внутри свой рисоватор есть, но он уебищный какой-то, руками или в scene builder fx сподручнее что-ли.
Связь между интерфейсом и кодом идет через setContentPane(panel) панель которая создаётся в рисовалке
Main и запуск и добавление обвязки - руками сами делаем


Jar to exe:

Launch4j там указывешь пути, мин/макс версии джавы и путь к jre
На свинге и обычное запустились норм, javafx как ожидалось не отработала, там какая то страшная ебка (custom jre или maven сборка или зависимости компоновать)


Jar with GUI

Для запуска/создания javafx.jar что из ide, что из консоли нужно толкать параметры при запуске
В итоге сделал ассоциацию .jar на батник, в котором запускаю java jar с параметрами и проброшенным названием


JavaFx:

Норм либа, более красивый подход к гуи, чем свинг
Есть контроллы, отдельный файл fxml с разметкой, и мейн
Интерфейс рисуешь не кодом а в scene builder, удобнее
Чтобы просто заюзать .jar собранный, надо передавать параметры vm options хитрый (как и при сборке), поэтому простым кликом в проводнике не заработает - привязать в винде ассоц не удалось, сделал см батник


Сторонние либы в IDE

На примере JavaFX, спец проект с параметром требует либо jdk с javafx либо либо передать в cp.
Делается это во вкладке project > modules .По идее само должно подключаться после загрузки sdk fx и его указания пути. Работает!
Потом индексируется и подсасывается можно в трее меню слева увидеть пункт external libraries


Maven moments:

Нужен для авто подгрузки либ к проекту, без cp ебки
Как pypl суть та же (загрузка модулей из репы удаленной) pip
//todo: попробовать maven заюзать


Spring

// todo: Ближе к концу 4 квеста глянуть свинг


Classpath moments:

Там мб путь к скомпил .classам проекта и путь к .jar библиотеке сторонней.
Это все передается в java -cp jar, path to classes при запуск, чтобы работало
Еще можно глобальный cp задать, и туда дописывать пути к либам, но это такое
//todo: standalone приложение с dependency которое запускается из себя


Gui

Сырой Awt не вариант
На swing довольно топорный но можно сделать интерфейс
JavaFX вроде с эффектами похожая тема (красивее, но надо спец проект начинать в IDE)
Swing:
Есть компоненты
Есть диалоги всплывающие
Естт всплывающее меню
Конструктор интерфейсов в ide(swing):


Развязка UI

От длительной операции надо в отдельном потоке делать, в основном сообщение, потом асинхр хрень досчитается и конец
Блокируем кнопку на время выполнения
SetText ("") очищаем поле после ввода


Swing + mvc:

Epic задача на чат


Parallel run IntelliJ

Edit config - allow parall run 2 checkbox on 2 classes
2 метода main в классах, запускаем первый, затем ну другой вкладке второй
Работает


Two methods avail 2 threads

На каждый метод свой объект лока


Sync outer/inner class

Там внимательно смотреть надо sybcronized(Outer.this.pole)


Compare

В treeset и подобных при вставке объектов своего класса лни должны реализов comparable иначе exception


Кастомный try with resources

Чтобы не появлялись try catch при close() внутри других try catch
Для этого кастомный класс делается implements Closeable и метод close()
Все после этого его обьект можно создавать в try w r и он сам закроется


Getter для boolean

IsDriverAvailbl()
return driverAvaible


Сравнить объекты по полю:

Comparable (compareTo)
Сomparator (compare)


Заюзать стороннюю либу Java

1) Копирнуть код
2) Создать обьект класса либы
3) Сделать подкласс наследующий от либы и родительского класса
4) Ипсользовать обёртку


Рефакторинг

Есть сайт про это рефактор.гуру там норм раскрыто
В кратце упрощение восприятия кода при сохр функционала
Ctrl alt shift T


Stream api

Collection.stream().forEach(
(p) -> {sout(p)};
Или forEach(sout::println)


Запуск thread из себя же:

New Thread(this, threadname)
А еще this.setHandler() делается


Проброс искл наверх:

В catch (Exception e) { throw e}
Если try catch в потоке сделано, то все ок, если runtime exception какой то мб произойти и это не учтено, то так можно застраховаться от останова


Вариации объявления

Можно тупа делать классы подклассы типа наследники иньерыецсов Runnable и тд
Можно делать короче на анонимных классах
А можно еще пижже (короче) на лямбдах


Super

Для класса без наследования вызывается для Object, с наследованием, для родителя тогда
Super.method
Super(params)


Executor vs executorService

Первый просто оборачивает логику старта потока за нас в execute
Второй позволяет пулять потоки автоматом или задавать их кол-во вручную, а также запускать callable с возвраьом значения future хери с ожиданием.
FutureTask позволяет из будущего с ожиданием получить return из Callable


Jenerics <>

Для класса значит что переменная <T> используется далее в коде. Потом в main уже при вызове его указывают.
Если <T extends Number> это ограничения. ? Знак не дочитал


Мониторинг java

jps ClassApp
jvisualvm --openpid Pid


Интерфейс маркер

Не содержит методов
Пр: serializable
Callback - передача методу в качестве агрумента другой метод (лямбду)


Функц интерфейс (содерж 1 метод)

Можно переписать в лямбду без исени функции, и толкнуть в анонимный класс. Получается так млжно создать task который поток без лишнего кода (в лек про потоки 1)
Runnable task = () -> {
Sout("smth")
};
Thread thread = new Thread(task);
thread.start()
И далее эту ебалу всю можно еще толкнуть в executorService()


Многопоточка

Thread(this, name) означает передачу текущего объекта (runnable) в констр нити
Interupt мб заменен на break в catch clause
ThreadPoolExecutor из concurency - более высокоур метод работы с нитями. Типа 3 потока а задач 9, сами по очереди там крутится будут
Callable как runnable нить но с возвратом результата
Future что-то ожидающее завершения таска и возвращающее результат как generic (обобщение) - асинхронное выполнение
Socket для работы с сетью


Daemon thread

По дефолту false и главный поток может закончится, а парвлельный будет бежать
Чтобы паралл потоки заканчивались с главным надо делать их demon true
Типл без maina демоны умрут, а обычные будут крутится и программа не остановиься пока есть хоть один рабочий поток
Перехват искл в потоках понятно более менее uncaughtexcp.
Искл в потоке можно не успеть перехватить, если в нем sleep и setDaemon(true). Типа main отрабатывает раньше, чем дойдет до перехвата искл, и поток закрывается


Наследов от внутр класса:

Extends Building.Apartments
Внутри нужно сделать конструктор куда передать параметром ссылку на род класс и там:
параметр.super()
А также передать все другие переменные которве есть в родителе


Escape хери / interface back

Момент с интерфейсами - пока в нем не появ метод, то его появление в потомке не даст возможность его заюзать в меине
Если надо найти исп однокго класса в других, кликаем ctrl по названию класса
Mvc "\t"


Anonymous classes

Либо создается потомок родителя
Либо имплементтруется интерфейс
Не имеют конструктора всесто него static block
У анонимных классов названия 1,2,3


Javadoc

Tools > generate > locale options utf-8 и что импортитб и куда
На выходе интерактивные html доки в браузере
Создается разметкой в комментах в коде


Множественное наслед

Делается через внутренний класс типа внутри tiger есть класс threadtiger
Ну и если нужно скастить определ класс к абс классу /интерфейсу то делается через внутренний класс


Inner classes:

Static inner - обьект вложенный может существовать сам по себе. Нет доступа к не статич членам верхнегг класса
Usual inner - не может. Есть, через имяВнешн.класса
Еще есть анонимные типа наследник без названия для переопределения метода и создания 1 экземпляра (пр. Thread) синтаксис ебливый
И локальные (в методе)


Передача по значению

В java все так передается, а не по ссылке
Примитивы копируются при передаче в парамеьры методов - значение исходное в методе не похерится.
Объекты дают копию ссылки на себя в метод. Но тк пульта 2 условно, то объект изменяется при манипуляциях.


Local class в методе

Должен иметь final внешний параметр чтобы иметь доступ к нему
Еще и может быть анонимным для сокращения кода, тогда надо делать return new blabla() { ...}; Или вызов переменных анонимных классов englishGreeting.greet()


Split vertically

Можно окно перетащить так в иде > клик по файлу сверху в панелях и поместить 2 файла на 1 жкран
Чето ебка какая то с анонимными классами и локальными, вложенными


Поля внешнего класса из внутр:

Есть связи наследник - родитель
Есть внешн - внутр
Поля внешнего во внутреннем (non static) видны просто (даже private, но с методами аккуратно, они не передаются внутрь)
А вот доступ к род методу, при условии, что во внутреннем классе, пусть анонимном есть роидтельский метод с таким же названием - надо юзать конструкцию Outer.this.method()


Открыть консоль в проводнике:

Shift + ПКМ


Android root

Есть bootloader
Есть режим recovery
Есть fastboot
Разблок загрузчик через настроки телефона
Скачать и поебаному ставить драйвера
Google sdk tools (adb.exe + fastboot.exe)
Драйвера от xiaomi раздельные на adb и выключить девайс в fastboot и там ставить драйвера fastboot
Потом кастомный рекавери twrp качаем и кидаем на девайс тулзой fastboot
Запускаем рекавери и там устанавливаем magisk
(лол это все чтобы поюзать artmoney)


Adobe premier:

Создание и экспорт шаблона заставки
Рендеринг чтобы не лагало
Эффекты стандартные премьера
Замедление плавное
Вперед назад
Попробовать:
Сторонние либы переходов
 экспериментальный эффект с палатками
Шрифты по подписке только typekit сами скачиваются
Лого
Сохранить цветокор можно в preset
Цветокорреция слоями чтобы каждый клип не ставить эффект
Кнопка магнитик ебучий слева на таймлайне не выкл


Функциональный интерфейс:

С одним методом (Runnable)
Лямбды: (o1, o2) -> o1.length() - o2.length()
Типа слева параметры, справа тело, он же ретурн


Электронная подпись:

Делал на флешку сертификат с криптопро для подписи на сайте markirovka.crpt.ru
Также teamviewer попробовал, топовая тема работает из коробки, удаленный доступ без ебки с rdp/vpn


Plugin shortcuts:

Ctrl alt A проверить задание
Ctrl alt H список заданий


Notepad regex hint

Можно было делать $ и в конце строки replace ', например
Или ^


Строки:

IndexOf аернет индекс символа/символов в строке
Строка при переводе в массив байт преобразуется через какую то кодировку. Т.е пишем в файл байты которые были преобразованы из исх строки
StringTokenizer это как split но не сразу, а последовательный


Inteelij coment

Иногда ругается на русский коммент
Разница между filereader и длинным fileinputstream: можно задать кастомную кодировку


Format string

Pad left: %-7s
Pad right: %7s
Scientific: .2e
Округление: .2f само
Позиция из параметров: 3$s


Исключения в потоках:

Делаем uncaughtexception
В констуктор своего исключения передаем(message, cause) где посл это исключение родитель, на основе которого наше появл


Reflection и тд

Можно вызвать Class clazz = Integer.class и получить инфу о классе
Оно же new Object().getClass()


Library java

Jar подложить в classpath (вручную параметром или переменной среды)
Далее можно импортить классы в коде
Claspath - гле компилеру искать классы


Запретить что-то в java

Означает перепоределить метод в потомке и тд
Гле бросать исключение вместо целевого действия метода


HashSet/Map

При вставке в эти коллекции вызывается hashcode у обьектов, и если он одинаковый, то вставится только последний
Но если equals переопределен тоже и неравен, то вставится (для каждого same hashcode много раз вызывается equals других объектов при вставке)
Плохой hashcode - медленная работа


Clone obj (создает новый обьект)

Чтобы не херить важный обьект делаем его копию, их 2 вида:
Неполная:
Если поля простые, без обектных, то встроенное клонирование все сделает. Сам класс реализ Cloneable
Полная:
Сами перепоредяем поля. Типо отдельно в сложном поле реазилуем Cloneable, где clone() дефолтный переопределяем а в родительском Clone() добавляем поле


Вспомогательные hashcode equals:

При alt ins По выбираемым полям сами генерятся
Objects.equals(var1, var2) null checked по асем полям через И
Objects.hash(var1, var2..)


Hashcode()/equals()

Сначала проверяется hashcode, потом equals
Для сравнения сами переопределяем, есть ряд правил как правильно делать
Hashcode для более быстрой проверки, чем equals ()
Проверка дробей крест на крест перемножением
Битовый сдвиг >> это умножение/деление на 2, может быть с заполнением 0 слева или 1
=======
У равных обьектов равные коды должны быть. Но одинаковые коды не значит, что обьекты равны (equals true - code same)
У одного обьекта код всегда один и тот же
Same code - equals may differ
Alt + inse auto generate HashCode equals


Reflections api

getModifiers()
isModifiersSet
method getMainMethod()
getDeclaredMethods()
Побитовые операции проверки установки модификаторов


Overflowed var norm value

Переполенная
byte a = (byte) 192. //-68
Int b = a + 256. /192
Ну и метод перевода dec to bin Integer.toBinaryString()


Целочисленные типы

Имеют 1 старший знаковый разряд. Это значит что если 8 битный byte начинается с 1, то чтобы его перевести в dec надо пееводить из доп кода
Такое представление оттртцательных целочисленных int


Serialize singleton

При десерел плодятся инстансы. Чтобы это победить, нужно в синглетоне добавить метод readResolve()
Обьект можно записать в массив байт через сереализацию (ну или в файл)


Memory usage:

Runtime.getRuntime().totalMemory()
freeMemory()


Вложенные классы:

Static:
Outer.Inner a = new Outer.Inner()
Non-static:
Outer out = new Outer()
Outer.Inner inn = out.new Inner()


Serialize moments:

Пустой конструктор в родителе, если ребенок serializable
Если родитель несериалайз, а потомок сериалайз, то нужно кастомный writeObject() и readObject() делать, где дописывать отсутств поля из род класса writeObject(name1).Тк поля родителя берутся default
Если сериал класс содержит ссылки на другие классы, то они также будут сериал вместе (если у них вкл сериал)


Достучаться до static

Метода/переменной из переменной объекта это класса можно, будет solution.m() тоже что и Solution.m()


В sout char[]

Выведет как string


Byteshit

Байт код java.class нечитаемая хуебола (не текст)
Бинарник любой файл который читатель не может прочитать
Побайтовая работа с файлами (но они текстовые, тогда результат такой же для кодировки англ или бинарные)
Бинарник - Каждый байт это не символ, это число как регистр


Tmp dir java

Sout(system.getProperty("java.io.tmpdir")


Serialize/Deserialize

Класс имплементс serializable
fos=FileOutputStream("file.bin")
Ous=ObjectOutputStream(fos)
Будет бинарным, нечитаемым глазами
Ous.writeObj(person1)
И наоборот
Файлик без директории создается в корне проекта (javarushtasks)
При этом вручную при записи через outputstream если открыть файлик блокнотом, то там чиьаемые строки будут. Тк интерпретируется как текстовый файл, и таковым является. Но бинарник это не такое
Можно пометить поле transient для пропуска сериализации
Нужно чтобы был конструктор без параметров при исп externalize
Static поля не сериализ
Final при externalize не раб, при serializ раб
Потомки exrenlaiz должны иметь пустые кострукторы


Assert

Типа смесь комментария т проверки условия для дебага
Inner class instance
new Solution().new A();


Парсинг html

Делается вручную регулярками (плохая идея)
Либой jsoup
Или вручную индексами/stack ом (очередью)


Matches()

If word.matches(regex) then do smth
Более компактная форма чем matcher


Multimap

Можно сделать на структуре Map<String, List<Double>> например
И еще можно в Sout(var + '\n') сделать для переноса строки


Регулярки:

\\p{P} | \\s
Все знаки пунктуации или пробел
[abc] будет найдет любой символ из a b c (один)
[0-9] числа
\b\d+\b граница слова начало число и граница слова конец число
Удалить чтото можно с помощью s.replaceAll(regex, replace)
[^0-9] == /D не числа
\B\D+\B найти слова не числа не пробелы, только составные строки с пробелами
\S*\d+\S* слова с цифрами
Можно проверить не выходя из IDE через лампочку


Построчное чтение

filereader.ready() тоже самое в символьном потоке, что и readline() == null
Matcher и pattern для регулярок


Adapter

Чтобы адаптировать А к Б
Надо чтобы класс адаптер реализовывал (наслед) класс Б и имел ссылку на инстанс Класса А
Ну и вызывал методы Б на инстансе А
Адаптировать А к Б - реализуем Б ссылка на А
====main====
ClassA A = new ClassA()
ClassB B = new Adapter(a)
B.methodsA()
Т.е. реализация из адаптера идет (A), а доступные методы из B


Try with resources:

Try (buffered reader ...) {
Readline
Само закрывает поток в конце


Собирал файлик из частей

Побайтово прикольно
Из Treemap и парсинга номера части файла
При appendе нужео вручную символ переноса строки делать методом System.lineSeparator().getbytes() или newLine()


PrintWriter:

Аналог filewriter для текстового формата
Тоже самое с помощью string.valueOf(int a) внутри .write()
Чтобы записать что угодно как массив байтов надо делать getBytes()


Отступ строки пробелами

Правый
String.format("%-8d%-5s", id, name)


Концепция select в java:

Var = null
For i in list
If i == id
Var = i
If var != Null
Do smth


"Зашифровать файл"

Stream byte read() + 10
Write etc


Считать файл:

Построчно через bufferedReader и inputStreamReader readline()
Можно побайтово через fileInputStream read()
Побайтово с буфером также но read(byte[] buffer) - buffer это куда будут считываться данные


Append file java

new FileOutputStream(file, true)
При создании fos без этого параметра исходные данные теряются при каждом создании обьекта такого над файлом. Типа пишем - стираем все, потом пишем.
Fileoutputstream при записи числа 20 запишет соотв символ. Чтобы записать символ как есть нужно либо кодами сопоставить либо использовать reader (там подавать либо число-код либо сам символ)




Дубликаты/кол-во вхождений:

Два цикла, если внутренний var = внешнему, то каунт++, затем во внешнем цикле удалить элемент, если каунт > 1
Найти каунты элементов и отсортировать - через map геморой, надо делать через индекс массива - arr[stream.read()]++ , потом искать в цикле там где макс значение, и искать индексы с макс значением
Далее выбирать все индексы со значением == макс


Reader vs stream:

Кароче есть stream они читают байты, и если там текст на кириллице, то его можно будет корретно преобразовать read() в чиселки и посмотреть
Если reader то это символьный поток и он сам преобразует 1 код в символ методом read() дефолтной кодировке (utf-8)
Если bufferedreader ьо можно строку целиком прочитать


Ascii побайтово:

FileInputStream read() считывает побайтово файл
Если там текст то он по ascii кодируется 1 символ 1 байт, и метод возвращает dec код в ascii каждого символа
В hex редакторе смотрел все по ascii
ByteStream for ascii
CharacterStream for unicode (16 байт на символ)
Unicode совпадает с ascii (все первые 127 символов), остальное байты это не латинские символы
Utf-8 конкретная кодировка и unicode (abstract representation)


Посмотреть символа кода в блокноте:

Alt press + код символа в ascii, на правой части
Выдаст символ


Character stream:

Записывает 1 символ за read() сам учитывая кодировку
Он может быть от 1 до 4 байт (utf-8)
В уникоде пара байтов 101 229 например соотв одному символу ð
Little endian big это порядок байтов


Блокировки:

2 sync метода
Пока один вызван, то пока он не отработает, второй не запустится
Если один метод критический то sync должен быть не только он, а все методы которые есть
=========
(1) Sync method == (2) sync(this) {}
Либо sync по классу (sync статического метода)
(3) Sync sync(Class1.class) {}
...(1,2,3) Блокировка по классу, по объекту, по внешнему объекту
"Кароче когда вызывается одним потоком синк метод / блок кода, то монитор обьекта блокируется, и другие потоки вообще никакие sync коды не могут выполнять, пока первый не отработает"
И ещк блокировка делается на внешний объект чтобы засинкать разные методы между собой общно
1720 задача - один обьект аккаунт, несколько потоков которые читают из account.write() account.read().Но эти методы sync по this поэтому пока один поток исполняет метод на, этом обьекте, другие потоки ждут, и не могут влезть нив какие свои sync блоки
Если sync по классу значит только один поток сможет выполнить этот статический метод, независимо от классов


Атомарность:

Если оперция выполняется в одно действие, и вряд ли другой поток успеет влезть
Чтобы избежать Atomic переменные надо юзать или блокировки (synchronize)
Double/long не атомарные, остальные примитивы атомарны


Тернарный оператор:

(условие1 true) ? ЕслиДа : Если Иначе


Реализовать интерфейс

Значит переопределить его методы
Для потока - runnable и run()
Для comparable - compareTo()
Для своего вывода обьекта в консоль - toString()
Сделать свой класс List'ом - реализовать все методы листа
В классе потомке - переопрделеить методы родителей
Своей исключение - throwable наследуем


Типчик:

Вернуть индекс вставленного элемента
Return list.size()-1
Кароче проверка символа в строке - делать contains/equals, не ==
Задача мб запускаться из консоли main тогда работаем с args. Из ide из консоли. Переходим в папку javasyntax до src, передаем полный package до сбилденного solution и далее параметры через пробел
И можно в intellij параметры передать в edit confige
В списке объект - вызвав для него get и изменить его поля так можно типа по ссылке (логическое удаление)


Syncronized

Если класс предполагается что будет использоваться нитями тогда он должен быть синхронизирован
Создаются объекты локи для синхронизации не на сам основной обьект, а на искусственный, чтобы избежать общей блокировки


yield()

Позволяет притормозить поток "снизить свой приоритет"


Общий ресурс потоков:

Надо с хтим аккуратней иначе паральелный доступ к одному ресурсу его раздрочит (пример сортировка массива, вывод в консоль, удал/добавл в списках)
Вывод в консоль смешивается
Списки просто несортируются


Мьютекс - объект "туалет":

Блокируется при использовании одним потоком


Синхронизация:

Это про одновременно монопольный доступ к какому то ограниченному ресурсу.
Синхронизированными могут быть блоки и или методы


Много потоков одна консоль ввода:

Есть atomic переменные (чтобы работать с несколькими потоками, похоже на volatile
В нескольких потоках считываем с консоли - ввод разбирается по потокам самостоятельно
Нужно только ready() методом проверять


Loops

Можно делать повторы в цикле
А можно рекурсией, вызывая метод сам себя нужное counterOut == counterIn раз


Unhandled exceptions

Есть метод который позволяет отработать runtime exceptions java core unhandled ...


Потоки в цикле:

В цикле запускаем
Потом получаем iый поток. Чтобы узнать жив ли он, юзаем sout(var.isAlive())
А чтобы заюзать его конкр методы надо его ещё привести к типу своему из абстрактного thread
Сичтыванте и запись в консоль одновременная в двух потоках дает хуеберду (всегда тока принт)


Потоки:

Join()
Sleep()
Interupt()
Start()
Если в цикле крутится дочерний поток, то вызов interupt не остановит его. Надо в условии цикла проверять выход + в перехват исключения добавлять interupt()


Volatile:

Такая переменная мб использована в разных потоках и будет иметь общий пул


Многопоточка:

Реализовать интерфейс runnable в классе
Реализовать метод run()
Создать обьект своего класса, передать в new thread(new class)
Запустить thread.start()
Или
Создать класс унаследованный от thread
Переопределить run()
Создать обьект своего класса и вызвать у него start()
========
А интерфейс может наследоваться от Runnable


Связывание

Раннее для private final static методов (метод init() в классе А будет вызван именно тот, что внутри А, а не его потомокв классе Б)
Динамическое связывание для всех других типов (для объекта класса Б вызовется метод переопределенный в Б, даже если в промежутке будет конструктор класса А)


Порядок выполнения:

1523
Статик блок
Main
Non static block
Конструктор, переменные


Порядок иниц перем:

Сначала статические переменные и блок статик, потом уже обычные переменные и конструкторы
Родитель затем ребенок


Паттерны:

Синглтон - 1 объект класса только
Шаблонный метод - абстрактный класс реализует общие шаги, потомки специфичные
Фабрика
Обертка (декоратор)
Адаптер


Отношения:

Наследование (is a)
Реализация
Ассоциация (has a)
Агрегация
Композиция
Посл вариант подразумевает создание объекта класса б внутри другого класса а (или наличие поля ссылки на объект другого класса)


Null класс:

(String) null
Может быть разных классов


Простой return;

Возврат из метода, в тч main
Как break но другой слегка


Sout(list)

[class@objId, class@objId]
Если надо меняем toString() и будет что хочешь


Классный способ цикла чтения с консоли:

While((key=reader.readline().equals("dosmth") | key.equals("dosmth2)) { }
Лучше, чем делать вызов чтения перед циклом, потом в конце тела, и break внутри


Цепочка методов:

Class1 имеет переменную типа Class2, последний реализует интерфейс с методом
class1.class2.method()


Классы вложенные в интерфейс

И такая хуета может быть


Instanceof

Class1 implements intf1
Class1 instance of intf1 > true


Не забываем break

В switch, иначе ебанутый баг, с последней веткой case будет


Классы и файлы:

Обращаться к вложенному классу из файла другого класса:
Solution.Hen
Можно сделать один public класс и внутри него много вложенных, тогда при компиляции будет 1 файл
Можно сделать несколько отдельых классов в одном файле (но только один сможет быть public), тогда будет несколько файлов при компиляции с префиксом solution$subclass.class
Best practice делать каждый класс в отдельном файле, все будут public, при компиляции раздельные классы будут


Интерфейс moments:

Создать объект интерфейса нельзя
Но можно создать объект класса его реализующий
Selectable selectable = new Food()


Инициализация переменных:

Статические и объектные могут быть обьявлены дез инициализации, тк компилер сам их пронитит 0 для int, или null для ссылочного типа
Но локальные переменные требуют инициализации вручную и не скомпилятся без нее


Filewriter/filereader

Filewriter не юзал, юзал outputstreamwriter + fileoutputstream
Bufferedreader вместе с inputstream и fileinputstream против scanner fileinputstream


Filewrite omg:

Чтобы файл записался надо вызывать flush() буфера


Расширение ссылочных типов:

При наследование идёт расширение функционала (но сужение по смыслу, менее абстрактно)
Расширять просто норм (более абстрактно)
Сужать надо с приведением типа (Type) var1 (по функционалу)


Работа с файлами java:

В питоне был менеджер контекста и readlines
Здесь же 2 способа:
Через bufferedReader и fileInputStream
Либо scanner
Или мб filereader ?


Формат строки java:

Sout("djd" + var1)
String.format("djs", var1)


Короткое имя класса:

variable.getClass().getSimpleName()
Просто гет класс даст путь с пакетами


Extends/implements :

Такое полотно допускается
Public class cla2 Extends cls1 implements intf1


Разница abs/intf:

Абстрактный класс для близких сущностей, плюс переменные
Интерфейс для слабосвязаных классов, без состояния


Методы в абс. классе

Метод либо с реализацией
Либо абстрактный
В интерфейсе же без такого уточнения


Полиморфизм moments:

Один интерфейс - много реализаций (1 имя функции - неск результатов в подклассах)
Набор методов определяется типом переменной, конкретная реализация классом ()


Indexof():

Возвращает индекс конкретного элемента в массиве (поиск)
Проитерировались по словарю, и увеличили счётчик (массив чисел) по нужному индексу для конкретной буквы словаря. Это все в цикле для строк, в цикле для массива символов


Immutable objects:

String str1 = "kek"
String str2 = "lel"
str2 = str1
str1 = "dhag"
Sout(str2): lel


Conversions

A = 5, B = 0
C = 5/0 exception
G = a/b infinity
Infinity to int/long = max_integer
Infinity to short/bytr = -1
Byte (128) = -128 типа по кругу начинается при превышенит
Char c = 'k' затем (int)c даст кодировку
Int i = 5
(Char) i даст символ такой то


Array remove elem

Когда удаляем/добавляем элемент нужно i++/i-- счетчик!


Intellij shortcut тип:

Psvm + TAB > main ()
I + TAB > foreach
fori + TAB > for
Ctrl D > копирует строку целиком где курсор
Ctrl W > выделяет слово как ctrl shift стрелка (shift обратно)
Ctrl Y > delete строку
Ctrl - + > свернуть развернуть блок кода текущий (ctrl shift -+ все блоки)
Ctrl alt O > удаление всех неисп импортов
Ctrl [ ] в начало метода или в конец
Справа подсвечивается код который не влез на экране
Ctrl g переход к строке
Ctrl delete удаляет все символы из строки после курсора
Alt + ins быстрое создание конструкторов, геттеры, сеттеры
Автоформат стиля ctrl alt i
Обернуть конструкцию в цикл ctrl alt t
Block comment ctrl shift /
Alt 1 дерево проектов
Alt ins на каталоге - создание файла/класса
Alt стрелки переход между вкладками
Alt 4 в блок Run переключаемся для ввода inputa напр (повторное нажатие - возврат)
Лкм + click на методе откроет его javadoc
Ctrl + alt + T surround with
Ctrl space выбор методов из всех возможных
Alt shift f10 выбор конфигурации запуска (чтобы не переключать для каждого задания)
At shift курсор - создаёт несколько курсоров !
Alt shift стрелки - перемещение строки
Bfrd - чтение с консоли
Frd filereader
Fwr - filewriter
Ctrl клик на название класса - переход к нему
R Ctrl + \ закрытие файла
Double shift - поиск по проекту (дурацкий)
Ctrl alt f7 (ctrl lkm) show usages (не find usages)
Ctrl shift f find in path
(!) Ctrl tab - переключение между alt1 и alt2 к коду
Alt 7 структура
Alt стрелки - прыгаем по методам
Alt +f2 меню контекстное для редактора или каталога
F10 меню верхнее файл 
* по корневому каталогу - откроет все папки
Alt + f s p прыгаем сразу на нужный пункт меню в окнах
Ctrl + f12 все методы 


Variable overflow:

Официальная методика
Берутся первые 8 бит из 16 (пример) и далее переводятся из доп кода в обычный - инвертируюется все биты кооме старшего и прибавляется 1 к результату.
Моя методика
Если в байт положить число больше чем range результат будет: 700 % 128 = - 68 (-min_byte + остаток (5 * 128 = 640; 700-640 = 60; -128 + 60 = -68))
Методика чела с jr
700 отнимаем 255 (700-256=444, не попадаем в интервал byte снова вычитаем и тд. В конце -68 и это диапазон byte значит и число)


Conversions

A = 5, B = 0
C = 5/0 exception
G = a/b infinity
Infinity to int/long = max_integer
Infinity to short/bytr = -1
Byte (128) = -128 типа по кругу начинается при превышенит
Char c = 'k' затем (int)c даст кодировку


Exceptions:

Ловим от частного к общему
В методах throws
В main try catch


StackTrace:

Thread.currentThread().getStackTrace()
Порядок вызовов функций в стеке (уровень вложенности и стектрейс тем больше, чем глубже функция относительно main)
printStackTrace() всегда пишет с частного к main внизу
Но стек исключений от верха самый последний вызов метода, ниже вызов вызывавшего его метода и тд. внизу main


Asci (utf-8):

Char c = 100; // символ d
Чем больше номер тем ниже по алфавиту


ContainsKey()

Сам пробегается по map и ищет определенный ключ. Не нужно итерироваться интегратором


Set delete

Делается через iterator
Тк индекса в set нет (так же как и в linked list)


Обход заеба For each

Делается копия коллекции которую надо изменять в цикле for
Пробегаемся по копии
Но изменяем оригинал коллекции


Custom shortcut:

File > settings > live templates > + add new template > abbrv + text > applicable in java > reformat ...


Java

Equals равенство строк
Equals object надо переопределить
== равенство ссылок


Debug intellij:

Делаем breakpoint
И щапускаем дебаг
+...


Jar from intellij:

Jar сбилденный - назыв artifact
Создаем проект в идее, пакет в папке project > src, в пакете java class. Потом пкм в коде и run.
Project structure > artifacts > + jar > from modules ... > Select main class
После build > build artifacts
После этого появится файл .jar в папке out
===run jar====
Sample project > edit configuration > + jar application > path to jar > run


Считывание с консоли java:

Обьект System.in (inputStream) > InputStreamReader > BufferedReader в переменную reader1
Потом reader1.readline()
Также можно через scanner сделать, но сказали что это тупо


Тип с классами:

Каждый файл это как минимум 1 класс:
Если в файле несколько раздельных классов то после компила будет несколько файлов .класс
И нужео указываиь какой класс Main в таком случае
Если класс Main 1, но внутри него вложены другие классы, нужно чтобы они были статик
